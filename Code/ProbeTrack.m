function ProbeTrack

% Runs MOT task with gap and variable post-gap probe-onset delay

% $LastChangedDate$

    try
        AssertOpenGL;
        InitializePsychSound;
        KbName('UnifyKeyNames');
        experiment = 'ProbeTrack7';

        % get user input
        [subject, nTargets, blockType] = ...
            DialogBox(sprintf('%s Parameters', experiment), ...
                      'Subject code:', '1', 1, ...
                      'Number of targets:', '4', 1, ...
                      'Block type (1, 2, 3):', '3', 1);

        % set any remaining IVs
        SOAlist = [0 3 6 96]; % # of frames
        probeTargetList = 0:1;

        % set any remaining control variables
        durGap = 10; % # of frames
        nStim = 8;

        % set up different block types
        switch blockType 
          case 1
            % training without gap
            practiceFlag = 1;
            pTrials = 10;
            xTrials = 40;
            durGap = 0; % # of frames
            blockTypeStr = 'NoGap';
            blockMesg = 'Initial Block without Gap';
          case 2
            % training with gap
            practiceFlag = 1;
            pTrials = 4;
            xTrials = 16;
            blockTypeStr = 'GapPrac';
            blockMesg = 'Training Block with Gap';
          case 3
            % experimental block
            practiceFlag = 0;
            pTrials = 5;
            xTrials = 120;
            blockTypeStr = 'GapExp';
            blockMesg = 'Experimental Block with Gap';
          case -1
            practiceFlag = 0;
            pTrials = 2;
            xTrials = 8;
            blockTypeStr = 'Testing';
            blockMesg = 'Testing Run';
          otherwise
            error('Block type of %d not supported', blockType);
        end
        totalTrials = xTrials + pTrials;

        % stimulus characteristics
        rectDisplay = [0 0 500 500];
        stimSize = 40;
        rectStim = [0 0 stimSize stimSize];

        % durations
        durCue = 60; % # of frames to present target cues
        durPostProbe = 60; % # of frames
        durFeedback = .746; % sec
        durPostTrialBlank = .5; % sec
        gapOnsetRange = [60 180]; % # of frames; bounds of range from which to pick pre-gap tracking duration
        gapOnsetRangeStr = sprintf('%d-%d', min(gapOnsetRange), max(gapOnsetRange));

        % define colors
        colBlack = [0 0 0];
        colWhite = [255 255 255];
        colMidGray = [128 128 128];
        colDarkGray = [64 64 64];
        colYellow = [240 240 0];
        colRed = [250 0 0];
        colBackground = colMidGray;
        colText = colBlack;

        % define color sets for each phase of the trial
        trackingColors= repmat(colDarkGray', 1, nStim);
        cueingColors = trackingColors;
        cueingColors(:, 1:nTargets) = repmat(colYellow', 1, nTargets);
        gapColors = repmat(colBackground', 1, nStim);

        % Set any remaining parameters
        preloadFlag = 1;

        % Define response keys
        respAbort = KbName('ESCAPE');
        if IsOSX
            respTarget = KbName('''"');
        elseif IsWin
            respTarget = KbName('''');
        else
            error('no keyboard mapping for this operating system');
        end        
        respDistractor  = KbName('a'); % a key (left-hand side)
        allowedResponses = [respTarget, respDistractor];

        % Tones
        samplingRate = 44100;
        paBeep = PsychPortAudio('Open', [], [], 0, samplingRate, 1);
        paClick = PsychPortAudio('Open', [], [], 0, samplingRate, 1);
        paBuzz = PsychPortAudio('Open', [], [], 0, samplingRate, 1);
        sndBeep = MakeBeep(880, .1, samplingRate);
        PsychPortAudio('FillBuffer', paBeep, sndBeep);
        sndClick = MakeBeep(1000, .01, samplingRate);
        PsychPortAudio('FillBuffer', paClick, sndClick);
        sndBuzz = MakeBuzz(.1, samplingRate);
        PsychPortAudio('FillBuffer', paBuzz, sndBuzz);

        % Miscellaneous setup
        seed = 100 * sum(clock);
        rand('twister', seed);
        dataFileName = sprintf('%s-%03d-data.txt', experiment, subject);
        [status, result] = system('echo $HOSTNAME');
        if exist('TestingRoom', 'file')
            computer = TestingRoom;
        elseif status == 0
            computer = strtok(result, '.');
            computer = computer(isletter(computer)); % remove any spaces or newlines
        else
            computer = 'unknown';
        end
        revision = '$Rev: 1048 $';
        revision = revision(7:end-2); % strip extra text from revision string generated by Subversion
        blocktime = now;

        % Open and set-up main window
        Screen('Preference', 'SkipSyncTests', 0);
        Screen('Preference', 'VisualDebugLevel', 4);
        screenNumber=max(Screen('Screens'));
        [winMain, rectMain] = Screen('OpenWindow', screenNumber, 0, [], 32, 2);
        refreshDuration = Screen('GetFlipInterval', winMain);
        Screen(winMain, 'BlendFunction', GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        [centerX, centerY] = RectCenter(rectMain);
        durSlack = refreshDuration / 2.0;

        % Turn cursor and keyboard echoing off
        HideCursor;
        ListenChar(2);

        % font setup
        Screen('TextFont', winMain, 'Arial');
        Screen('TextSize', winMain, 24);

        % present instructions
        Screen('FillRect', winMain, colBackground);
        DrawFormattedText(winMain, ...
                          [blockMesg, '\n\n\n', ...
                           '--------------------------------------------------\n\n\n'...
                           sprintf('Track %d targets out of %d total stimuli\n\n\n', nTargets, nStim), ...
                           'Respond when one disk flashes red\n\n' ...
                           'Press YES if the red disk is a target\n\n' ...
                           'Press NO if the red disk is NOT a target\n\n\n\n', ...
                           sprintf('Press any key to begin block of %d trials', totalTrials)], ...
                          'center', 'center', colText);
        KbReleaseWait;
        Screen('Flip', winMain);
        Screen('FillRect', winMain, colBackground);
        [keyTime, keyCode] = KbStrokeWait;
        if keyCode(respAbort)
            error('abort key pressed');
        end
        Screen('Flip', winMain);

        % initialize block-level DVs
        blockRT = zeros(totalTrials, 1) - 1;
        blockAcc = zeros(totalTrials, 1) - 1;

        subBlockList = 1:2;
        trialCounter = 0;
        for subBlock = subBlockList
            if subBlock == 1
                nTrials = pTrials;
                prac = 1;
            else
                nTrials = xTrials;
                prac = 0;
            end
            if practiceFlag
                prac = 1;
            end
            if nTrials <= 0, contiunue; end

            % balance independent variables
            n = ceil(nTrials / numel(SOAlist) / 2);
            [SOA, probeTarget] = ...
                BalanceFactors(n, 1, SOAlist, probeTargetList);

            if numel(SOA) ~= nTrials && prac == 0
                warning('unbalanced design in sublock %d', subBlock);
            end

            for trial = 1:nTrials
                trialCounter = trialCounter + 1;
                trialtime = now;

                % pre-trial blank
                ClearScreen;
                % DrawFormattedText(winMain, 'Configuring trial...', 'center', 'center', colText);
                Screen('Flip', winMain);

                % randomize gap duration (in frames)
                gapOnsetTime = Randi(gapOnsetRange(2) - gapOnsetRange(1)) + gapOnsetRange(1);
                % compute total trial duration (in frames)
                trialDuration = gapOnsetTime + durGap + SOA(trial) + durPostProbe; % duration of trial in frames
                                                                                                    % compute stimulus positions for entire trial
                trajectories = MakeTrajectories(nStim, trialDuration, stimSize);

                % select probe
                if probeTarget(trial) == 1
                    % probe a target
                    probeItem = Randi(nTargets);
                else
                    % probe a distractor
                    probeItem = Randi(nStim - nTargets) + nTargets;
                end

                % set colors for probe frames
                probeColors = trackingColors;
                probeColors(:, probeItem) = colRed';

                % Set up timing variables
                tFrameOnset = zeros(size(trajectories, 3), 1) - 1;

                % Reset suppression of keypress output on every trial, since Windows
                % intermittently resets suppression.
                ListenChar(2);

                % Draw plain display and prompt for trial start
                ClearScreen;
                PaintFrame(trajectories(:, :, 1), nStim, trackingColors, winMain);
                DrawFormattedText(winMain, ...
                                  sprintf('Press a key to start trial %d', ...
                                          trialCounter), ...
                                  'center', 'center', colText);
                KbReleaseWait;
                Screen('Flip', winMain);
                [keyTime, keyCode] = KbStrokeWait;
                if keyCode(respAbort)
                    error('abort key pressed');
                end

                % Draw cue frame
                ClearScreen;
                PaintFrame(trajectories(:, :, 1), nStim, cueingColors, winMain);
                tLastOnset = Screen('Flip', winMain);
                targNextOnset = tLastOnset + durCue * refreshDuration - durSlack;

                % main animation sequence
                postProbeFrames = 0;
                probeOnsetTime = -1;
                response = -1;
                responseTime = -1;
                tResponseEnd = -1;
                % draw first post-cue frame
                ClearScreen;
                PaintFrame(trajectories(:, :, 1), nStim, cueingColors, winMain);
                tFrameOnset(1) = Screen('Flip', winMain, targNextOnset);
                % motion sequence
                for frame = 2:gapOnsetTime
                    % pre-gap interval
                    ClearScreen;
                    PaintFrame(trajectories(:, :, frame), nStim, trackingColors, winMain);
                    tFrameOnset(frame) = Screen('Flip', winMain);
                end
                for gLoop = 1:durGap
                    % gap interval
                    frame = frame + 1;
                    ClearScreen;
                    PaintFrame(trajectories(:, :, frame), nStim, gapColors, winMain);
                    tFrameOnset(frame) = Screen('Flip', winMain);
                end
                for sLoop = 1:SOA(trial)
                    % SOA interval
                    frame = frame + 1;
                    ClearScreen;
                    PaintFrame(trajectories(:, :, frame), nStim, trackingColors, winMain);
                    tFrameOnset(frame) = Screen('Flip', winMain);
                end			
                % present probe and continue motion while checking for a response every frame
                while response == -1
                    postProbeFrames = postProbeFrames + 1;
                    frame = frame + 1;
                    ClearScreen;
                    if postProbeFrames <= durPostProbe
                        PaintFrame(trajectories(:, :, frame), nStim, probeColors, winMain);
                    end
                    Screen('DrawingFinished', winMain);
                    [keyIsDown, KbTime, keyCode] = KbCheck;
                    if keyIsDown
                        response = find(keyCode);
                        responseTime = KbTime;
                    end
                    tLastOnset = Screen('Flip', winMain);
                    if frame <= numel(tFrameOnset)
                        tFrameOnset(frame) = tLastOnset;
                    end
                    if probeOnsetTime < 0
                        probeOnsetTime = tLastOnset;
                    end
                end

                % Wait for key release
                if response > 0
                    while any(keyCode(response))
                        [keyIsDown, KbTime, keyCode] = KbCheck;
                    end
                    tResponseEnd = KbTime;
                end                    

                % compute RT and accuracy
                if responseTime > 0
                    RT = round((responseTime - probeOnsetTime) * 1000); % RT in ms
                    dur = round((tResponseEnd - responseTime) * 1000); % response dur in ms
                else
                    RT = 0;
                    dur = 0;
                end
                if isempty(response)
                    % no response
                    respString = 'none';
                    acc = -1;
                elseif numel(response) > 1
                    % multiple keys pressed
                    respString = 'multi';
                    acc = -2;
                elseif response == respTarget
                    respString = 'target';
                    if probeTarget(trial)
                        acc = 1;
                    else
                        acc = 0;
                    end
                elseif response == respDistractor
                    respString = 'distractor';
                    if probeTarget(trial)
                        acc = 0;
                    else
                        acc = 1;
                    end
                else
                    % some other key was pressed
                    respString = sprintf('%d', response);
                    acc = -3;
                end

                % compute durations
                durFrames = diff(tFrameOnset(tFrameOnset > 0)) * 1000;

                % output data
                dataFile = fopen(dataFileName, 'r');
                if dataFile == -1
                    header = ['exp\tsub\tcode\trev\tcomp\truntime\ttrialtime\t' ...
                              'nstim\trefreshdur\tcuedur\tgapdur\tgapOnsetRange\tdurPostProbe\tgapOnsetTime\t' ...
                              'blocktype\tprac\ttrial\tntargets\tsoa\tprobeTarget\t' ...
                              'resp\tacc\trt\tmeanFrameDur\tminFrameDur\tmaxFrameDur\n'];
                else
                    fclose(dataFile);
                    header = [];
                end
                dataFile = fopen(dataFileName, 'a');
                if dataFile == -1
                    error('cannot open data file %s for writing', dataFileName);
                end
                if ~isempty(header)
                    fprintf(dataFile, header);
                end
                %                              %rev    %runtime    %refresh   %gapdur         %blocktype      %soa    %resp   %rt %framedurs
                fprintf(dataFile, '%s\t%d\t%s\t%s\t%s\t%f\t%f\t%d\t%0.6f\t%d\t%d\t%s\t%d\t%d\t%s\t%d\t%d\t%d\t%d\t%d\t%s\t%d\t%d\t%0.3f\t%0.3f\t%0.3f\n', ...
                        experiment, subject, mfilename, revision, computer, blocktime, trialtime, ...
                        nStim, refreshDuration, durCue, durGap, gapOnsetRangeStr, durPostProbe, gapOnsetTime, ...
                        blockTypeStr, prac, trialCounter, nTargets, SOA(trial), probeTarget(trial), ...
                        respString, acc, RT, mean(durFrames), min(durFrames), max(durFrames(2:end)));
                fclose(dataFile);

                % Prepare feedback
                switch acc
                  case -1
                    feedback = 'NO RESPONSE!';
                  case -2
                    feedback = 'MULTIPLE KEYS PRESSED!';
                  case -3
                    feedback = 'NON-RESPONSE KEY PRESSED!';
                  case 0
                    feedback = 'Wrong!';
                  case 1
                    feedback = 'Correct!';
                end

                % Present feedback
                ClearScreen;
                DrawFormattedText(winMain, sprintf('%s\n\n\nResponse Time = %0.0f ms', ...
                                                   feedback, RT), 'center', 'center', colText);
                tLastOnset = Screen('Flip', winMain);
                targNextOnset = tLastOnset + durFeedback - durSlack;
                ClearScreen;

                % store trial info
                blockRT(trial) = RT;
                blockAcc(trial) = acc;

                tLastOnset = Screen('Flip', winMain, targNextOnset);
                targNextOnset = tLastOnset + durPostTrialBlank - durSlack;
                ClearScreen;
                Screen('Flip', winMain, targNextOnset);
            end % end trial loop

            % output performance summary
            fprintf('\nBlock %d', subBlock);
            fprintf('\npcor  = %0.1f%%', 100 * mean(blockAcc(blockAcc >= 0)));
            fprintf('\nrtcor = %0.0f ms\n', mean(blockRT(blockAcc > 0)));
        end % end block loop

        ClearScreenCompletely;
        DrawFormattedText(winMain, ...
                          ['Thank you for participating!\n\n\n', ...
                           sprintf('Overall accuracy = %0.0f%%\n\n', 100 * mean(blockAcc(blockAcc >= 0))), ...
                           sprintf('Average response time = %0.0f ms\n\n\n', ...
                                   mean(blockRT(blockAcc > 0 & blockRT > 0))), ...
                           'Please inform the experimenter that you are done.'], ...
                          'center', 'center', colText);
        Screen('Flip', winMain);
        while 1
            [keyTime, keyCode] = KbStrokeWait;
            if keyCode(respAbort)
                break;
            end
        end
    catch
        ple;
    end

    Priority(0);
    ListenChar;
    ShowCursor;
    fprintf('\n# of open windows = %d\n', numel(Screen('Windows')));
    Screen('CloseAll');
    PsychPortAudio('Close');
    clear all;


function varargout = DialogBox (title, varargin)

    n = (nargin - 1);
    if nargout ~= n / 3
        error('input and output arguments must match');
    end
    prompt = varargin(1:3:n);
    defaults = varargin(2:3:n);
    toNum = varargin(3:3:n);
    param = inputdlg(prompt, title, 1, defaults);
    if isempty(param)
        error('Dialog box cancelled');
    end
    varargout = cell(1, nargout);
    for i = 1:length(param)
        p = param{i};
        if toNum{i}
            n = [];
            if ~exist(p)
                n = str2num(p);
                if ~isempty(n)
                    varargout{i} = n;
                end
            end
            if isempty(n)
                error('parameter ''%s'' value ''%s'' could not be converted to numeric as requested', ...
                      prompt{i}, p);
            end
        else
            varargout{i} = p;
        end
    end
end

function [buzz, rate] = MakeBuzz (dur, rate)

    if nargin < 2 || isempty(rate) 
        rate = 44100;
    end
    
    freqs = 100 * [1:15, 75:100];

    n = 0;
    buzz = zeros(1, length(0:rate*dur));
    for f = freqs
        buzz = buzz + sin(2 * pi * f * (0:rate*dur) / rate);
        n = n + 1;
    end
    buzz = buzz / n;
    buzz = (buzz - min(buzz)) / (max(buzz) - min(buzz)) * 2 - 1;
end


function ClearScreen
    Screen('FillRect', winMain, colBackground);
end


function ClearScreenCompletely
    Screen('FillRect', winMain, colBackground);
end


function PaintFrame(coordinates, nStim, diskColors, window)
    Screen('DrawDots', window, coordinates(:, 1:nStim, :), stimSize, diskColors, [], 2);
%     for i = 1:nStim
%         placeRect = CenterRectOnPoint(rectStim, coordinates(i, 1), coordinates(i, 2));
%         screen(window, 'FillOval', diskColors(i, :), placeRect);
%     end
end

function trajectories = MakeTrajectories (nStim, nFrames, stimSize)

% generates MVT trajectories
% given the number of objects and frames, returns positions for each object for each frame
% code adapted from Jen Dimase's motPictMem, Justin Junge
% started 9/10/2004
% current 9/14/2004

%  Creates target Locations.
    trajectories = zeros(2, nStim, nFrames);

% coordinate system
    cellSize = round(rectDisplay(3:4)/7); % size of initial position grid cell

    [fieldRect, xOffset, yOffset] = CenterRect(rectDisplay, rectMain);

    x = 0:6;
    xloc = xOffset + cellSize(1) * x;
    yloc = yOffset + cellSize(2) * x;

    [gridy, gridx] = meshgrid(yloc, xloc);

    shufflegrid = randperm(49);
    shufflegrid = shufflegrid(1:nStim);
    trajectories(1, :, 1) = gridx(shufflegrid(:));
    trajectories(2, :, 1) = gridy(shufflegrid(:));

    % motion parameters
    repulsionPower = 10000; % not sure where the value comes from
    inertia = 1;
    pathchange = 1.5; % Determines Degree of Change on Motion Paths
    forcefieldDistance = 1.5 * stimSize; % 1.5 = Item Repulsion only occurs within a field around each shape 25% the size of the shape. 

    initMotion = (-4:4) * pathchange;
    frameMotion = (-2:2) * inertia;
    rXmove = initMotion(Randi(9, [1, nStim]));
    rYmove = initMotion(Randi(9, [1, nStim]));

    for f = 2:nFrames
        aa = f-1;

        % Repulsion 
        repel = ones(2, nStim) * 0.00001;

        for object=1:nStim;
            % this code is useless
            %             thisLocation = repmat(trajectories(object, :, aa), nStim, 1); % creates nStim X 2 array of object object's coordinates
            %             distances  = thisLocation - trajectories(:, :, aa);
            %             absoluteDistances = abs(distances);
            %             i = find((absoluteDistance(1) < forcefieldDistance) & (absoluteDistance(2) < forcefieldDistance));

            for qq=1:nStim;
                if qq ~= object
                    distance = trajectories(:, object, aa) - trajectories(:, qq, aa);
                    absoluteDistance = abs(distance);
                    if (absoluteDistance(1) < forcefieldDistance) && (absoluteDistance(2) < forcefieldDistance)
                        if distance(1) ~= 0 && distance(2) ~= 0
                            addrepel = 1./((distance.^2) .* sign(distance));
                            repel(:, object) = repel(:, object) + repulsionPower * addrepel;
                        end
                    end
                end
            end
        end

        rXchange = frameMotion(Randi(5, [1, nStim]));
        rYchange = frameMotion(Randi(5, [1, nStim]));
        newrm = [-1 1];

        % X Trajectories
        for object = 1:nStim
            rXmove(object) = rXmove(object) + rXchange(object) + repel(1, object);										% Makes change to X motion

            % floor and ceiling
            if rXmove(object)==0;
                rXmove(object) = newrm(Randi(2));
            end

            if rXmove(object) > 4*pathchange
                rXmove(object) = 4*pathchange;
            end
            if rXmove(object) < -4*pathchange
                rXmove(object) = -4*pathchange;
            end

            trajectories(1, object, f) = (trajectories(1, object, aa) + rXmove(object));

            if trajectories(1, object, f) >= (fieldRect(3) - stimSize); 		% Bounces off right
                trajectories(1, object, f) = (fieldRect(3) - stimSize);
                rXmove(object) = -(4*rXmove(object));	
            end			
            if  trajectories(1, object, f) <= fieldRect(1);					% Bounces off left
                trajectories(1, object, f) = fieldRect(1);
                rXmove(object) = -(4*rXmove(object));											
            end	
        end

        % Y Trajectories
        for object = 1:nStim

            rYmove(object) = rYmove(object) + rYchange(object) + repel(2, object);										% Makes change to Y motion

            if rYmove(object)==0;
                rYmove(object) = newrm(Randi(2));
            end

            if rYmove(object) > 4*pathchange
                rYmove(object) = 4*pathchange;
            end
            if rYmove(object) < -4*pathchange
                rYmove(object) = -4*pathchange;
            end

            trajectories(2, object, f) = (trajectories(2, object, aa) + rYmove(object));							
            if trajectories(2, object, f) >= (fieldRect(4) - stimSize);													% Bounces off Bottom
                trajectories(2, object, f) = (fieldRect(4) - stimSize);
                rYmove(object) = -(4*rYmove(object));	
            end

            if 	trajectories(2, object, f) <= fieldRect(2);																% Bounces off Top
                trajectories(2, object, f) = fieldRect(2);
                rYmove(object) = -(4*rYmove(object));									
            end
        end
        %d(f, :) = sqrt(rXmove.^2 + rYmove.^2);
    end
    %mean(d)
end % end MakeTrajectories function

end
