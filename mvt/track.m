function ShiftTrack2()% ShiftTrack2: runs ShiftTrack2, with conditions defined by path files.% $Id: track.m,v 1.2 2003/11/11 16:37:11 fencsik Exp $% Can observers tolerate a longer gap duration if all items disappear at once?% constant blank duration method rather than staircase% syntax asynchtrack3()% uses tGenerator6a; generate a set of practice trials and a set of experimental trials% based on asynchtrack1 of 7/14/03% created 9/23/2003% version of 9/23/2003% version of 9/23/2003 - unselected correct ball feedback, removed staircase, data output just accuracy (RSB)% version of 10/3/2003 - modified to passively run pathfile generated by tgenerator8a.m, added trial level feedback (DEF)% version of 10/15/2003 - made into ShiftTrack2, saved more data (DEF)% 11/10/2003 - added check to ensure frame duration is approx. 13 ms. If it%              seems to be over, then exit cleanly and tell RA to restart.global screenXglobal screenYglobal MainWindowglobal nDirectionsExperimentName = 'ShiftTrack2';minimumAccuracy = '60%';% min frame duration in ms: if average frame duration is greater than this% value, then panic and exit. The MATLAB interpreter is sometimes slow and% can't draw fast enough, and this accomodates that.minFrameDuration = 15;tracer = 0;logging = 0;if logging;	LogFileName = [ExperimentName '.log'];	logFile = fopen(LogFileName,'a');	fprintf(logFile, '\nStarted on %s\n', datestr(now));end;dataFileName = [ExperimentName '_Data.txt'];% trialTypes = [-0.5 0.0 0.5 1.0 1.5];% nTrialTypes = length(trialTypes);condition = 1;% Present initial prompt% prompt = {'subject''s initials',  %           ['trials per condition (x' num2str(nTrialTypes) ' conditions)'],% 		  'disks to track', % 		  'trial duration (movie frames)',% 		  'blank duration (movie frames)'};prompt = {'Subject''s initials',		  'Number of disks to track',		  'Practice paths file', 		  'Experimental paths file'};defaults = {'xxx', '5', 'prac1', 'real1'};answer = inputdlg(prompt, 'Experimental Setup Information', 1, defaults);% check for cancel button-pressif size(answer) < 1	'Experiment Cancelled'	returnend% now decode answer[subject, tracknumber, practicePathsFile, experimentalPathsFile] = deal(answer{:});tracknumber = str2num(tracknumber);% derive initial 3 letters of subject name [junk nameSize] = size(subject);if nameSize < 3	sInitial = subject;	sInitial((nameSize+1):3) = 'x';else	sInitial = subject(1:3);end% other major variablesdataFile = fopen(dataFileName, 'a');fprintf(dataFile,'sub,time,pracfile,expfile,blocktype,cond,blankdur,trial,speed,shift,ndisks,tracknumber,framedur,error,nerrors\n');fclose(dataFile);formatString = '%s,%s,%s,%s,%s,%d,%d,%d,%d,%4.2f,%d,%d,%6.4f,%d,%d\n';%subject,timestamp,practicePathsFile,experimentalPathsFile,blocktype,condition,blankDuration,trial,movementRate,shiftFactor(trial),nDisks,tracknumber,averageFrameDuration,error,nErrors% video setupimageX=50;imageY=50;imageRect = [0 0 imageX imageY];coreRect = imageRect - [0 0 4 4];ballRect = CenterRect(coreRect, imageRect);MainWindow = screen(0, 'OpenWindow', [], [], 8);screenRect = screen(0, 'Rect');screenX = screenRect(3);screenY = screenRect(4);hz = round(screen(MainWindow, 'FrameRate'));white = WhiteIndex(MainWindow);black = BlackIndex(MainWindow);gray = round((white+black)/2);if round(gray)==white	gray=black;enddarkGray = (gray+black)/2;lightGray = (gray+white)/2;% now set colorsred = 1;blue = 2;green = 3;yellow = 4;clut = screen(MainWindow, 'GetClut');clut (red + 1, :) = [255 0 0];clut (blue + 1, :) = [0 0 255];clut (green + 1, :) = [0 255 0];clut (yellow + 1, :) = [255 255 0];LoadClut(MainWindow, clut);screen(MainWindow, 'FillRect', gray);screen(MainWindow, 'TextFont', 'Times');screen(MainWindow, 'TextSize', 24);hidecursor;% framesPerMovieFrame = 2;% load functions into memory% these functions take time to load into memory, but will remain in memory until clearedscreen('Screens'); % this function opens or cloeses windows on or off screencenterrect(imageRect, screenRect);% centers first rect in second rectKbCheck; % checks whether a key is pressed downGetSecs; % returns the number of seconds since the computer started% set the state of the random number generator to some random value (based on the clock)tau = clock;rand('state',sum(100*tau));state=rand('state');seedFileName = ['seed-', sInitial, 'C', num2str(condition)];save (seedFileName, 'tau');% open other windows% off screen stimulus windowstimulus(1) = screen(MainWindow, 'OpenOffscreenWindow', [], screenRect);stimulus(2) = screen(MainWindow, 'OpenOffscreenWindow', [], screenRect);if tracer;	tracerPaths = screen(MainWindow, 'OpenOffscreenWindow', [], screenRect);end;screen(stimulus(1), 'FillRect', gray);screen(stimulus(2), 'FillRect', gray);% big eraserscreenBlank=screen(MainWindow, 'OpenOffscreenWindow',  gray, screenRect); %make some beeps[beep, samplingRate] = makeBeep(650,.1);[errbeep, samplingRate] = MakeBeep(850,.11);% load paths file (includes 	 'practicePaths', 'experimentalPaths', 'rate', 'duration', 'nDisks', 'practiceTrials', 'experimentalTrials', 'practiceLambda', 'experimentalLambda', 'nDirections', 'experimentalStarts', 'practiceStarts', 'predictedMovieFrameDuration');%load(practicePathsFile);% predictedMovieFrameDuration = 40; % expected frame duration; if this is wrong, then the trial durationwill be off, as well as the speed% totalMovieFrames = round(1000*(duration/predictedMovieFrameDuration));% blankWindow(1) = round(2000/predictedMovieFrameDuration); % blank comes at least 2 seconds after start of tracking% blankWindow(2) = totalMovieFrames - round(1000/predictedMovieFrameDuration); % blank comes no later than 1 seconds before end of tracking % define the stimulus presentation loop% time is measured in frames, and measures the total stimulus time% the frame array keeps track of which frame of its trajectory each% object is in.loop = {'		while (frame <= (trialFrames-trialShift));''			thisFrame = mod(frame - 1, 2) + 1;''			lastFrame = mod(frame, 2) + 1;''			time1 = GetSecs;''			for n = 1:nDisks;''				if frame > 1;''					screen(''CopyWindow'', eraserPointer, stimulus(lastFrame), imageRect, lastPlaceRect{n}, ''transparent'');''				end;''				placeRect{n} = [trajectory(n,1,frame+frameOffset(n))-imageX  trajectory(n,2,frame+frameOffset(n))-imageY  trajectory(n,1,frame+frameOffset(n))  trajectory(n,2,frame+frameOffset(n))];'%				% for each object, when it begins its blank, then move it %				% to the frame it should be in when it reappears.'               if (blankDuration > 0);''   				if (preBlank(n)) & (frame >= startBlankTime(n));''			    		preBlank(n) = 0;''   					frameOffset(n) = trialShift;''			    	end;''				    if (frame >= startBlankTime(n)) & (frame <= endBlankTime(n));''	    				pointer = eraserPointer;''	    			else;''		    			pointer = ballPointer;''   				end;''               else;''                   pointer = ballPointer;''               end;''				screen(''CopyWindow'', pointer, stimulus(thisFrame), imageRect, placeRect{n}, ''transparent'');''			end;''			if tracer;''				screen(''CopyWindow'', tracerPaths, stimulus(thisFrame), [], [], ''transparent'');''			end;''			screen(MainWindow, ''WaitBlanking'', 1);''			screen(''CopyWindow'', stimulus(thisFrame), MainWindow);''			frameDuration(frame) = GetSecs - time1;''			lastPlaceRect = placeRect;''			frame = frame + 1;''		end;'};pointerNames = {'ballPointer', 'currentSelectionBall', 'unselectedBall', 'selectedCorrectBall', 'unselectedCorrectBall', 'selectedErrorBall'};diskBackgroundColors = {'[]', 'lightGray', 'gray', 'green', 'yellow', 'red'};diskForegroundColors = {'darkGray', 'darkGray', 'darkGray', 'darkGray', 'darkGray', 'darkGray'};for p = 1:6	eval([pointerNames{p}, ' = screen(MainWindow, ''OpenOffScreenWindow'', ', diskBackgroundColors{p}, ', imageRect);']);	eval(['screen(', pointerNames{p}, ', ''FillOval'', black, imageRect);']);	eval(['screen(', pointerNames{p}, ', ''FillOval'',', diskForegroundColors{p}, ', ballRect);']);enderaserPointer = screen(MainWindow, 'OpenOffScreenWindow', [], imageRect);screen(eraserPointer, 'FillOval', gray, imageRect);if tracer;% define tracer window and stimuli	tracerRect = CenterRect([0 0 2 2], imageRect);	tracerPointer = screen(MainWindow, 'OpenOffScreenWindow', [], imageRect);	screen(tracerPointer, 'FillOval', black, tracerRect);	firstTracerRect = CenterRect([0 0 6 6], imageRect);	firstTracerPointer = screen(MainWindow, 'OpenOffScreenWindow', [], imageRect);	screen(firstTracerPointer, 'FillOval', red, firstTracerRect);end;pathsFile = practicePathsFile;load(pathsFile);% instructionsnDiskString = num2str(nDisks);tracknumberString = num2str(tracknumber);taskInstructionString = {'In this experiment, you are asked to track a number of disks moving around the screen';['At the beginning of each trial, you will see ', nDiskString, ' dark gray disks on a medium gray background'];[tracknumberString, ' of these disks will blink on and off. These are your targets.'];'After the targets stop blinking, all the disks will start to move around the screen.';['Your task is to keep track of the ', tracknumberString, ' targets as they move.'];};if condition == 1 	gapInstructionString = {	'At some point during the trial, all the disks will briefly become invisible, and then reappear.';	};else	gapInstructionString = {	'One by one, the disks will briefly become invisible and then reappear.';	};endresponseInstructionString = {'When the disks stop moving, the arrow cursor will appear.';'Use the mouse to click on all of the targets.';'The disk you have selected will be highlighted in green if you are correct';'and you will hear a low tone.';'If you click on a non-target, it will be highlighted in red';'and you will hear a high tone.';['After you have clicked ', tracknumberString, ' times, any targets you missed will blink in yellow.'];};feedbackInstructionString = {'After each experimental trial, you will receive feedback''on your performance so far.';'The feedback will tell you how you did on the previous trial';'and how you have done on all trials for the current block.';['Your goal should be to maintain an overall accuracy of at least ' minimumAccuracy '.'];};screen('CopyWindow', screenBlank, MainWindow);CenterCellText(MainWindow, taskInstructionString, 50);CenterText('press any key to continue', 0, 250);FlushEvents('keyDown');GetChar;screen('CopyWindow', screenBlank, MainWindow);CenterCellText(MainWindow, gapInstructionString, 50);CenterText('press any key to continue', 0, 250);FlushEvents('keyDown');GetChar;screen('CopyWindow', screenBlank, MainWindow);CenterCellText(MainWindow, responseInstructionString, 50);CenterText('press any key to continue', 0, 250);FlushEvents('keyDown');GetChar;screen('CopyWindow', screenBlank, MainWindow);CenterCellText(MainWindow, feedbackInstructionString, 50);CenterText('press any key to continue', 0, 250);FlushEvents('keyDown');GetChar;slowFlag = 0;for block = 1:2	if block == 1		pathsFile = practicePathsFile;		blockMessage = ' practice';		blocktype = 'practice';		% figure out the max number of repetitions that can fit given the number of		% trials present in the practice path file:		%trialTypeList = shuffle(repmat(trialTypes, 1, floor(nTrials / nTrialTypes)));	else		pathsFile = experimentalPathsFile;		blockMessage = ' experimental';		blocktype = 'exp';		% Generate and shuffle list of possible trial types:		%trialTypeList = shuffle(repmat(trialTypes, 1, repetitions));	end	load(pathsFile);	trajectory = paths{1};	if logging;		fprintf(logFile, 'trialTypeList = \n');		fprintf(logFile, '%4.2f ', shiftFactor);		fprintf(logFile, '\n');	end;		% 	% check to make sure there are enough frames in the path file:% 	if trialDuration > totalMovieFrames;% 		clear screen;% 		fprintf(1,'ERROR: Trial duration exceeded duration of trajectories in paths file %s.mat\n\n', pathsFile);% 		return;% 	end;% % 	% check to make sure there are enough trials in the paths file:% 	if size(trialTypeList, 2) > nTrials% 		clear screen;% 		fprintf(1, 'ERROR: Number of trials requested (%d) exceeds number of trials in paths file %s.mat (%d)\n\n',...% 		        size(trialTypeList, 2), pathsFile, nTrials);% 		return;% 	end;%	nTrials = size(trialTypeList, 2);	screen('CopyWindow', screenBlank, MainWindow);	[newX newY] = CenterText(['Press any key to begin ', num2str(nTrials), blockMessage, ' trials']);	FlushEvents('keyDown');	GetChar;	nTracked = zeros(nTrials,1);	correct = 0;	for trial = 1:nTrials		trialString = num2str(trial);		trialFrames = movieFrames(trial);		trialShift = shiftAmount(trial);		blankWindow(1) = round(2000/predictedMovieFrameDuration); % blank comes at least 2 seconds after start of tracking		blankWindow(2) = trialFrames - round(1000/predictedMovieFrameDuration); % blank comes no later than 1 seconds before end of tracking 				timestamp = datestr(now);				if logging;			fprintf(logFile, 'Starting trial %d\n', trial);			fprintf(logFile, '  trialFactor = %4.2f\n', trialFactor);		end;				% select start time for blank interval		startBlankTimeRange = blankWindow(2) - blankWindow(1);		if condition == 1			% set start of blank to the same frame for all disks			startBlankTime = ones(1, nDisks);			startBlankTime = startBlankTime * randi(startBlankTimeRange);		else			% generate different random starting blank frames for each disk			startBlankTime = randi(startBlankTimeRange, [1, nDisks]);		end		startBlankTime = blankWindow(1) + startBlankTime;		endBlankTime = startBlankTime + blankDuration;		finalFrame = trialFrames; % finalFrame is leftover from dougtrack4				% get coordinates		trajectory = paths{trial};		startCoordinates = starts{trial};				%present the stimuli		hidecursor;				% blank both stimulus screens		screen('CopyWindow', screenBlank, stimulus(1)); 		screen('CopyWindow', screenBlank, stimulus(2)); 		screen('CopyWindow', screenBlank, MainWindow);		% generate tracers		if tracer;			%screen('CopyWindow', screenBlank, tracerPaths,[],[],'transparent');			for d = 1:nDisks;				for t = startBlankTime(d):endBlankTime(d);					screen('CopyWindow', tracerPointer, tracerPaths, imageRect, [trajectory(d,1,t)-imageX  trajectory(d,2,t)-imageY  trajectory(d,1,t)  trajectory(d,2,t)],'transparent');				end;				screen('CopyWindow', firstTracerPointer, tracerPaths, imageRect, [trajectory(d,1,startBlankTime(d))-imageX  trajectory(d,2,startBlankTime(d))-imageY  trajectory(d,1,startBlankTime(d))  trajectory(d,2,startBlankTime(d))],'transparent');			end;		end;		[newX newY] = CenterText(['Press any key to begin trial ', trialString]);		FlushEvents('keyDown');		GetChar;		for a = 1:nDisks			screen('CopyWindow', ballPointer, stimulus(2), [], [startCoordinates(a,1) - imageX startCoordinates(a,2) - imageY startCoordinates(a,1) startCoordinates(a,2)], 'transparent');			if a > tracknumber				screen('CopyWindow', ballPointer, stimulus(1), [], [startCoordinates(a,1) - imageX startCoordinates(a,2) - imageY startCoordinates(a,1) startCoordinates(a,2)], 'transparent');			end		end			%flash the tracked balls 4 times to cue them		for flash = 1:9			screen('CopyWindow', stimulus(mod(flash,2)+1), MainWindow);			WaitSecs(.5);		end			%clear the stimulus window		% 		screen('CopyWindow', screenBlank, MainWindow);		screen('CopyWindow', screenBlank, stimulus(1));		screen('CopyWindow', screenBlank, stimulus(2));		FlushEvents('keydown');				% now present stimuli				initTime = getsecs; %check the start time time		time1 = initTime;		frameDuration = zeros(trialFrames,1);		preBlank = ones(1,nDisks);		frameOffset = zeros(1,nDisks);		frame = 1;		 		if logging;			fprintf(logFile, '  Entering loop...');		end;				% show the movie:			priorityLevel=MaxPriority(MainWindow,'WaitBlanking'); 		rush(loop,priorityLevel);				if logging;			fprintf(logFile, 'done\n');		end;		        %trialDuration = GetSecs - initTime		averageFrameDuration = sum(frameDuration) / trialFrames * 1000		% 		max(frameDuration)*1000		% 		min(frameDuration)*1000		        % if framerate is too slow, then exit with a warning:        if averageFrameDuration > minFrameDuration            slowFlag = averageFrameDuration;            feedbackString = {'COMPUTER ERROR:  SLOW FRAME DURATION';                              ['Average frame duration = ' num2str(slowFlag)];                              '';                              'The block needs to be restarted.';                              'Please inform the experimenter immediately.';                              '';                              'Experimenter: Press any button to exit,';                              'then restart the block.'                          };            screen('CopyWindow', screenBlank, MainWindow);            CenterCellText(MainWindow, feedbackString, 30);            FlushEvents('keyDown');            GetChar;            break;        end;		% chill out		% screen(MainWindow, 'WaitBlanking', 10);		%at end of trial, check the response with a mouseclick		testFrame = finalFrame;				FlushEvents(['mouseUp'],['mouseDown']);		ShowCursor([0]);		% 		screen(MainWindow, 'FillRect', darkGray);		locationError = ones(1, tracknumber);%everything starts as an error				% compute center of each stimulus		nClicks = 0;		diskVector = zeros(1, nDisks);				if logging;			fprintf(logFile, '  Starting response collection...');		end;						while nClicks < tracknumber			button = 0;			% 			nClicks = nClicks +1;						while button == 0				% redraw stimulus				[x, y, button] = getmouse;				for d = 1:nDisks					placeRect{d} = [trajectory(d, 1, testFrame) - imageX trajectory(d, 2, testFrame) - imageY trajectory(d, 1, testFrame) trajectory(d, 2, testFrame)];					if diskVector(d) == 1;						screen('CopyWindow', selectedCorrectBall, MainWindow, imageRect, placeRect{d});					elseif diskVector(d) == 2;						screen('CopyWindow', selectedErrorBall, MainWindow, imageRect, placeRect{d});					else;						if IsInRect(x, y, placeRect{d})							screen('CopyWindow', currentSelectionBall, MainWindow, imageRect, placeRect{d});						else							screen('CopyWindow', unselectedBall, MainWindow, imageRect, placeRect{d});						end					end				end				[x, y, button] = getmouse;				if button == 1 %if the mouse button is pressed					while button == 1 %wait until it is released						[x, y, button] = getmouse; %get the x,y coordinates of the location at which the mouse button was released					end					button = 1; %reset the button to 1 so that you can break out of the loop				end			end					% is mouse within this rect?			clickedInARect = 0;			for d = 1:nDisks				% 				testFrame				placeRect{d} = [trajectory(d, 1, testFrame) - imageX trajectory(d, 2, testFrame) - imageY trajectory(d, 1, testFrame) trajectory(d, 2, testFrame)];				if IsInRect(x, y, placeRect{d})					if diskVector(d) == 0						clickedInARect = 1;						if d <= tracknumber							screen('CopyWindow', selectedCorrectBall, MainWindow, imageRect, placeRect{d});							snd('play', beep);							locationError(d) = 0;							diskVector(d) = 1;						else							screen('CopyWindow', selectedErrorBall, MainWindow, imageRect, placeRect{d});							snd('play', errbeep);							diskVector(d) = 2;						end					end %if diskVector(d) == 0				end %if IsInRect(x, y, placeRect{d})			end %for d = 1:nDisks			if clickedInARect == 1				nClicks = nClicks + 1;			end				end % while nClicks...				% if there were any errors, then flash the unselected correct disks:		if any(diskVector == 2)			for d = 1:nDisks				if d <= tracknumber					if diskVector(d) == 0						screen('CopyWindow', unselectedBall, stimulus(2), [], placeRect{d}, 'transparent');						screen('CopyWindow', unselectedCorrectBall, stimulus(1), [], placeRect{d}, 'transparent');					else						screen('CopyWindow', selectedCorrectBall, stimulus(2), [], placeRect{d}, 'transparent');						screen('CopyWindow', selectedCorrectBall, stimulus(1), [], placeRect{d}, 'transparent');					end				elseif d > tracknumber					if diskVector(d) == 0						screen('CopyWindow', ballPointer, stimulus(2), [], placeRect{d}, 'transparent');						screen('CopyWindow', ballPointer, stimulus(1), [], placeRect{d}, 'transparent');					else							screen('CopyWindow', selectedErrorBall, stimulus(2), [], placeRect{d}, 'transparent');						screen('CopyWindow', selectedErrorBall, stimulus(1), [], placeRect{d}, 'transparent');					end				end			end			%flash the unselected correct balls 3 times			for flash = 1:6				screen('CopyWindow', stimulus(mod(flash,2)+1), MainWindow);				WaitSecs(.333);			end		end				if logging;			fprintf(logFile, 'done\n');		end;						error = max(locationError);		nErrors = sum(locationError);		% save data		dataFile = fopen(dataFileName, 'a');		count = fprintf(dataFile, formatString, subject, timestamp, practicePathsFile, experimentalPathsFile, blocktype, condition, blankDuration, trial, movementRate, shiftFactor(trial), nDisks, tracknumber, averageFrameDuration, error, nErrors);		fclose(dataFile);					[newX newY] = CenterText('Press any key to continue', 0, 0, black);		FlushEvents('keyDown');		GetChar;		nTracked(trial) = tracknumber - nErrors;		correct = correct + (1 - error);				feedbackString = {['Last Trial: ' num2str(nTracked(trial)) '/' num2str(tracknumber) ' correct'];						  ['Average of: ' num2str(sum(nTracked(1:trial))/trial,2) '/' num2str(tracknumber) ' correct'];						  ' ';						  ['All ' num2str(tracknumber) ' correct on ' num2str(100*correct/trial,'%1.0f%%') ' of trials'];						  ' ';						  ' ';						  'Press any key to continue'						 };		screen('CopyWindow', screenBlank, MainWindow);		[newX newY] = CenterCellText(MainWindow, feedbackString, 30);		FlushEvents('keyDown');		GetChar;	end % trial loop        if slowFlag > 0        break;    end;    end % block loopif logging;	fprintf(logFile, 'Finished on %s\n', datestr(now));	fclose(logFile);end;clear screen;