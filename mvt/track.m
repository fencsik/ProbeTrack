function track()

%%% track:
%%% presents trials in the Multiple Object Tracking experiments. Uses path files 
%%% generated by generator.m
%%% Authors: David Fencsik (based on file by Todd Horowitz)
%%%
%%% $LastChangedDate$

% min/max frame duration in ms: if average frame duration is outside of these bounds, then
% panic and exit. The MATLAB interpreter is occassionally off and this catches it.
% 
% 2005-02-24: This may no longer be necessary.  The timing errors
% could have been due to a power problem at 64 Sidney St. and seems to
% have disappeared since that problem was fixed. (DEF)
minFrameDuration = 11;
maxFrameDuration = 20;

%%% initiate logging%%%
logging = 0;
if logging;
   LogFileName = ['track.log'];
   logFile = fopen(LogFileName,'a');
   fprintf(logFile, '\nStarted on %s\n', datestr(now));
end;

%%% input dialog %%%
%%% input dialog %%%
dlgParam = {'subject'      , 'Subject initials'               , 'xxx';
            'pathFile'     , 'Path file name'                 , 'DurPaths';
            'pBlock'       , 'Practice block (1 = yes)'       , '0';
            'pTrials'      , 'Number of practice trials'      , '4';
            'xTrials'      , 'Number of experimental trials'  , '4';
            'nTargetsList' , 'Number of Targets'              , '2';
            'moveTypeList' , 'Moving? (1 = yes, 0 = no)'      , '0 1';
            'correctDAC'   , 'Correct for 10-bit DAC'         , '1';
           };
param = inputdlg(dlgParam(:, 2), ['Experiment Parameters'], 1, dlgParam(:, 3));
if size(param) < 1
   return
end
for a = 1:length(param)
   p = param{a};
   n = str2num(p);
   if isempty(n)
      str = 'p';
   else
      str = 'n';
   end
   eval([dlgParam{a, 1} ' = ' str ';']);
end

%%% set any fixed parameters
asynchronous = 0;
shift = 1;

%%% initialize RNG
seed = sum(100*clock);
rand('state', seed);

%%% load path file, extract information, set up path order, and check consistency
load(pathFile);
[nDisks, nCoord, nPaths] = size(startPositions);
nTrials = pTrials + xTrials;
if nTrials > nPaths
   error(sprintf('path file %s cannot support %d total trials; max is %d', pathFile, nTrials, nPaths));
end
if durationFlag == 2  % duration levels are balanced
   durList = unique(pathDurations);
   nDur = length(durList);
   pathDurations
   % figure out how many paths per duration level
   nPathsPerDuration = nPaths / nDur, % this should be an integer
   if nPathsPerDuration ~= round(nPathsPerDuration)
      error(sprintf('path file %s has unbalanced number of paths per duration'), pathFile);
   end
   % generate shuffled list of paths for each duration level
   pathList = zeros(nDur, nPathsPerDuration);
   for d = 1:nDur
      pathList(d, :) = Shuffle(find(pathDurations == durList(d)))';
   end
   % set up list of possibly balanced duration levels for practice trials
   if pTrials > 0
      durIndexPrac = repmat(1:nDur, [1, ceil(pTrials / nDur)]);
   end
   % set up counters for each duration level
   pathCounter = ones(nDur, 1);
else % duration levels are not balanced
   % randomize paths
   nDur = 1;
   pathList = randperm(nPaths);
   pathCounter = 1;
end
durIndexList = 1:nDur;

%%% other info
dataFileName = sprintf('%sData.txt', experiment);
computer = strtok(pwd, ':');
blocktime = now;

screenNumber = max(Screen('Screens'));
winMain = Screen(screenNumber, 'OpenWindow', [], [], 8);
rectScreen = Screen(winMain, 'Rect');
[centerX, centerY] = RectCenter(rectScreen);
refreshDuration = 1 / Screen(winMain, 'FrameRate', []); % sec/frame
rectDisplay = CenterRect(rectDisplay, rectScreen);

HideCursor;

%%% Define colors %%%
colBackground    = 1;
colForeground    = 2;
colText          = 3;
colInstructions  = 4;
colDisk          = 5;
colDiskCorrect   = 6;
colDiskError     = 7;
colDiskIndicator = 8;
colDiskBorder    = 9;
colTransparent   = 10;
colOffWhite      = 11;
colFixation      = 12;
clut = Screen(winMain, 'GetClut');
clut(colBackground + 1, :)    = [191 191 191];
clut(colForeground + 1, :)    = [  0   0   0];
clut(colText + 1, :)          = [  0   0   0];
clut(colInstructions + 1, :)  = [  0   0   0];
clut(colDisk + 1, :)          = [254 254 254];
clut(colDiskCorrect + 1, :)   = [  0 255   0];
clut(colDiskError + 1, :)     = [255   0   0];
clut(colDiskIndicator + 1, :) = [255 255   0];
clut(colDiskBorder + 1, :)    = [  0   0   0];
%clut(colTransparent + 1, :)   = [255 255 255];
clut(colOffWhite + 1, :)      = [254 254 254];
clut(colFixation + 1, :)      = [255   0   0];
colTransparent = WhiteIndex(winMain);
if correctDAC
   LoadClut(winMain, clut*1023/255);
else
   LoadClut(winMain, clut);
end;

Screen(winMain, 'FillRect', colBackground);

Screen(winMain, 'TextFont', 'Monaco');
Screen(winMain, 'TextSize', 18);

%%% define some tones %%%
beepCorrect = MakeBeep(1000, .01);
beepError   = MakeBeep(880, .2);
Snd('Play', beepCorrect);


%%% Define display windows %%%
winDisplayBlank = Screen(winMain, 'OpenOffscreenWindow', colBackground, rectDisplay);
Screen(winDisplayBlank, 'FrameRect', colForeground, [], 1, 1);
winDisplay = Screen(winMain, 'OpenOffscreenWindow', colBackground, rectDisplay);
Screen('CopyWindow', winDisplayBlank, winDisplay);
winDB = zeros(2, 1);
for d = 1:2
   winDB(d) = Screen(winMain, 'OpenOffscreenWindow', colBackground, rectDisplay);
   Screen('CopyWindow', winDisplayBlank, winDB(d));
end


%%% Define disks %%%
diskDiameter = diskRadius * 2;
border = 2;
rectDisk    = [0 0 diskDiameter diskDiameter];
diskNames        = {'', 'Correct', 'Error', 'Indicator', 'MouseOver', 'Blank'};
diskBackgrounds  = {'[]', '[]', '[]', '[]', 'colOffWhite', 'colTransparent'};
diskColors       = {'colDisk', 'colDiskCorrect', 'colDiskError', 'colDiskIndicator', 'colTransparent', 'colTransparent'};
diskBorder       = {'border', 'border', 'border', 'border', '[]', '[]'};
diskBorderColors = {'colDiskBorder', 'colDiskBorder', 'colDiskBorder', 'colDiskBorder', 'colTransparent', 'colTransparent'};
for d = 1:length(diskNames)
   name = sprintf('winDisk%s', diskNames{d});
   eval(sprintf('%s = Screen(winMain, ''OpenOffScreenWindow'', [], rectDisk);', name));
   if ~isempty(diskBackgrounds{d})
      eval(sprintf('Screen(%s, ''FillRect'', %s);', name, diskBackgrounds{d}));
   end
   eval(sprintf('Screen(%s, ''FillOval'', %s);', name, diskColors{d}));
   if ~isempty(diskBorder{d}) > 0 & ~isempty(diskBorderColors{d})
      eval(sprintf('Screen(%s, ''FrameOval'', %s, [], %s, %s);', ...
                   name, diskBorderColors{d}, diskBorder{d}, diskBorder{d}));
   end
end



%%% Define animation loop
%%% 1. Show initial display
%%% 2. Cue targets
%%% 3. Pause
%%% 4. Tracking interval
animationLoop = {
   'startTime = GetSecs;'
   'Screen(''CopyWindow'', winDB(1), winMain, [], rectDisplay);'
   'Screen(winMain, ''WaitBlanking'', round(.5 / refreshDuration));'
   'for f = [2 1 2 1 2 1 2 1];'
   '   Screen(''CopyWindow'', winDB(f), winMain, [], rectDisplay);'
   '   Screen(winMain, ''WaitBlanking'', round(1/3 / refreshDuration));'
   'end;'
   'Screen(''CopyWindow'', winDB(1), winMain, [], rectDisplay);'
   'Screen(winMain, ''WaitBlanking'', round(.25 / refreshDuration));'
   'for f = 1:nFrames;'
   '   Screen(''CopyWindow'', winDisplayBlank, winDisplay);'
   '   if f < gapOnset | f >= gapOffset;'
   '      for d = 1:nDisks;'
   '         Screen(''CopyWindow'', diskPointer(d), winDisplay, [], rectStim(d, :, f), ''transparent'');'
   '      end;'
   '   end;'
   '   Screen(''CopyWindow'', winDisplay, winMain, [], rectDisplay);'
   '   Screen(winMain, ''WaitBlanking'');'
   '   frameDisplayTime(f) = GetSecs;'
   'end;'
   'endTime = GetSecs;'
                };


%%% balance independent variables
NumberOfTrials = xTrials;
IVs = {%'probeTarget'   , 0:1;
       'nTargets'      , nTargetsList;
       'moveType'      , moveTypeList;
       'durIndex'      , durIndexList;
      };
nVariables = size(IVs, 1);
varLength = zeros(nVariables, 1);
listLength = 1;
for v = 1:nVariables
   varLength(v) = length(IVs{v, 2});
   listLength = listLength * varLength(v);
end
nRepetitions = ceil(NumberOfTrials / listLength);
len1 = listLength;
len2 = 1;
[dummy, index] = sort(rand(listLength * nRepetitions, 1)); 
for v = 1:nVariables
   len1 = len1 / varLength(v);
   eval([IVs{v, 1} ' = repmat(reshape(repmat(IVs{v, 2}, len1, len2), listLength, 1), nRepetitions, 1);']);
   eval([IVs{v, 1} ' = ' IVs{v, 1} '(index);']);
   len2 = len2 * varLength(v);
end
if listLength * nRepetitions ~= NumberOfTrials
   warning('unbalanced design');
end
clear NumberOfTrials IVs nVariables varLength listLength nRepetitions v dummy len1 len2 index;


% %%% Prepare/present instructions
% instr = cell(2, 1);

% if nTargets >= 1 & nTargets <= 9
%    nTargetsString = sprintf('%d', nTargets);
% else
%    error(sprintf('%d targets not supported', nTargets));
% end

% if moveType == 0
%    instr{1} = {'Instructions';
%                '';
%                'In this experiment, you need to keep track of some disks on ';
%                'the screen.  At the start of each trial, you will see 10    ';
%                ['white disks on a gray background.  ' nTargetsString ' of these disks will    '];
%                'blink on and off: these are your targets.  After the disks  ';
%                'stop blinking, the disks will stay in place for several     ';
%                'seconds. Your task is to keep track of the targets          ';
%                'throughout the trial.                                       ';
%                '';
%               };
% else
%    instr{1} = {'Instructions';
%                '';
%                'In this experiment, you need to keep track of some disks on ';
%                'the screen.  At the start of each trial, you will see 10    ';
%                ['white disks on a gray background.  ' nTargetsString ' of these disks will    '];
%                'blink on and off: these are your targets.  After the disks  ';
%                'stop blinking, all the disks will begin to move around the  ';
%                'screen.  Your task is to keep track of the targets          ';
%                'throughout the trial.                                       ';
%                '';
%               };
% end
% instr{2} = {'Instructions';
%             '';
%             'Once the trial ends, the arrow cursor will appear.  Use the ';
%             'mouse to click on each of the targets.  If you click on a   ';
%             'target, it will be highlighted in green and you will hear a ';
%             'click.  If you click on a non-target, it will be highlighted';
%            ['in red and you will hear a beep.  Once you have selected ' nTargetsString '  '];
%             'disks, any targets that you missed will blink in yellow.    ';
%             '';
%             '';
%            };

% for a = [1 2]
%    if ~isempty(instr{a})
%       Screen(winMain, 'FillRect', colBackground);
%       CenterCellText(winMain, instr{a}, colInstructions, 30);
%       CenterText(winMain, 'Click to continue', colInstructions, 0, 250);
%       MouseWait(winMain);
%    end
% end

Screen(winMain, 'FillRect', colBackground);

fprintf('START PATH FILE %s\n', pathFile);

for trial = 1:nTrials
   fprintf('START TRIAL %d\n', trial);
   trialtime = datestr(now);
   
   Screen('CopyWindow', winDisplayBlank, winMain, [], rectDisplay);
   CenterText(winMain, 'Please wait...', colText);
   
   prepStart = GetSecs;

   %%% get trial parameters
   if trial <= pTrials
      prac = 1;
      trialIndex = Randi(xTrials);
   else
      prac = 0;
      trialIndex = trial - pTrials;
   end

   %%% determine trial duration index
   if durationFlag == 2 & prac == 1
      idur = durIndexPrac(trial);
   else
      idur = durIndex(trialIndex);
   end

   if pBlock
      prac = 1;
   end

   %%% pick trial path
   path = pathList(idur, pathCounter(idur));
   pathCounter(idur) = pathCounter(idur) + 1;
   
   nFrames = pathDurations(path);
   pos = startPositions(:, :, path);
   delta = startVelocities(:, :, path);
   gapOnset = nFrames - blankDuration;
   gapOffset = nFrames;
   rectStim = zeros(nDisks, 4, nFrames);

   % generate trajectories
   for f = 1:nFrames

      rectStim(:, :, f) = [pos - diskRadius, pos + diskRadius];

      % test future positions for bouncing
      next = pos + delta;
      bounceX = (next(:, 1) < rectBoundary(RectLeft) | next(:, 1) > rectBoundary(RectRight))';
      bounceY = (next(:, 2) < rectBoundary(RectTop) | next(:, 2) > rectBoundary(RectBottom))';
      if any(bounceX), delta(bounceX, 1) = -1 * delta(bounceX, 1); end
      if any(bounceY), delta(bounceY, 2) = -1 * delta(bounceY, 2); end

      pos = pos + delta;

   end

   % If static trial, then set all pre-gap frames to be identical to the pre-gap frame
   if moveType(trialIndex) == 0
      rectStim(:, :, 1:(gapOnset-2)) = repmat(rectStim(:, :, gapOnset - 1), [1, 1, gapOnset - 2]);
   end

   fprintf('Trial duration   = %0.3f sec (%d frames)\n', ...
           nFrames * refreshDuration, nFrames);
   fprintf('Preparation time = %0.3f sec.\n', GetSecs - prepStart);

   diskPointer = repmat(winDisk, [nDisks, 1]);

   Screen('CopyWindow', winDisplayBlank, winMain, [], rectDisplay);
   CenterText(winMain, sprintf('Click to begin trial %d of %d', trial, nTrials), colText);
   MouseWait(winMain);
   
   %%% Initialize some variables and pre-load some functions into memory
   Screen(winMain, 'WaitBlanking');
   startTime = GetSecs;
   endTime = 0;
   this = 1;
   next = 2;
   frameDisplayTime = zeros(nFrames, 1);

   %%% Prepare cue displays
   for d = 1:2
      Screen('CopyWindow', winDisplayBlank, winDB(d));
   end
   for d = 1:nDisks
      Screen('CopyWindow', diskPointer(d), winDB(1), rectDisk, rectStim(d, :, 1), 'transparent');
      if d > nTargets(trialIndex)
         Screen('CopyWindow', diskPointer(d), winDB(2), rectDisk, rectStim(d, :, 1), 'transparent');
      end
   end
   Screen('CopyWindow', winDB(1), winMain, [], rectDisplay);
   WaitSecs(.5);

   %%% Display animation loop
   %Rush(animationLoop, 0);
   Rush(animationLoop, MaxPriority(winMain, 'WaitBlanking', 'GetSecs'));

   actualFrameDurations = diff(frameDisplayTime);

   for d = 1:2
      Screen('CopyWindow', winDisplayBlank, winDB(d));
   end

   SetMouse(centerX, centerY, winMain);
   diskSelected = zeros(nDisks, 1);
   nDisksSelected = 0;
   rectStimAdjusted = zeros(nDisks, 4);
   for d = 1:nDisks
      rectStimAdjusted(d, :) = OffsetRect(rectStim(d, :, nFrames), rectDisplay(RectLeft), rectDisplay(RectTop));
   end
   ShowCursor(0);
   while nDisksSelected < nTargets(trialIndex)
      screen('CopyWindow', winDisplayBlank, winDB(1));
      mouseOverDisk = 0;
      FlushEvents('mouseUp', 'mouseDown');
      [x, y, button] = GetMouse(winMain);
      for d = 1:nDisks
         if ~diskSelected(d) & IsInRect(x, y, rectStimAdjusted(d, :))
            Screen('CopyWindow', diskPointer(d), winDB(1), [], rectStim(d, :, nFrames), 'transparent');
            mouseOverDisk = d;
         elseif diskSelected(d) & d <= nTargets(trialIndex)
            Screen('CopyWindow', winDiskCorrect, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
         elseif diskSelected(d)
            Screen('CopyWindow', winDiskError, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
         else
            Screen('CopyWindow', diskPointer(d), winDB(1), [], rectStim(d, :, nFrames), 'transparent');
         end
      end
      if mouseOverDisk > 0
         if any(button)
            nDisksSelected = nDisksSelected + 1;
            if mouseOverDisk <= nTargets(trialIndex)
               diskSelected(mouseOverDisk) = 1;
               Snd('play', beepCorrect);
               Screen('CopyWindow', winDiskCorrect, winDB(1), [], rectStim(mouseOverDisk, :, nFrames), 'transparent');
            else
               diskSelected(mouseOverDisk) = 1;
               Snd('play', beepError);
               Screen('CopyWindow', winDiskError, winDB(1), [], rectStim(mouseOverDisk, :, nFrames), 'transparent');
            end
         else
            Screen('CopyWindow', winDiskMouseOver, winDB(1), [], rectStim(mouseOverDisk, :, nFrames), 'transparent');
         end
      end
      Screen(winMain, 'WaitBlanking');
      Screen('CopyWindow', winDB(1), winMain, [], rectDisplay);
      if any(button)
         [x, y, button] = GetMouse(winMain);
         while any(button)
            [x, y, button] = GetMouse(winMain);
         end
      end
   end % while nDisksSelected < nTargets(trialIndex)
   HideCursor;
   nCorrect = sum(diskSelected(1:nTargets(trialIndex)));
   allCorrect = (nCorrect == nTargets(trialIndex));
   selectedString = repmat('1', [1, nDisks]);
   selectedString(find(diskSelected)) = '2';

   dataFile = fopen(dataFileName, 'r');
   if dataFile == -1
      header = ['exp,sub,computer,blocktime,pathfile,path,prac,trial,trialtime,' ...
                'nframes,refreshdur,ndisks,ntargets,blankdur,asynch,shift,move,' ...
                'ncor,selected,meanframedur,minframedur,maxframedur'];
   else
      fclose(dataFile);
      header = [];
   end
   dataFile = fopen(dataFileName, 'a');
   if dataFile == -1
      error(sprintf('cannot open data file %s for writing', dataFileName));
   end
   if ~isempty(header)
      fprintf(dataFile, '%s\n', header);
   end
   %                  %exp  %computer      %trial         %nDisks     %shift   %ncor %framedurs
   fprintf(dataFile, '%s,%s,%s,%f,%s,%d,%d,%d,%s,%d,%0.4f,%d,%d,%d,%d,%d,%d,%d,%s,%0.4f,%0.4f,%0.4f\n', ...
           experiment, subject, computer, blocktime, pathFile, path, prac, trial, trialtime, ...
           nFrames, refreshDuration * 1000, nDisks, nTargets(trialIndex), blankDuration, ...
           asynchronous, shift, moveType(trialIndex),  ...
           nCorrect, selectedString, ...
           mean(actualFrameDurations) * 1000, ...
           min(actualFrameDurations) * 1000, max(actualFrameDurations) * 1000);
   fclose(dataFile);

   if nCorrect < nTargets(trialIndex)
      for d = 1:2
         Screen('CopyWindow', winDisplayBlank, winDB(d));
      end
      for d = 1:nDisks
         if diskSelected(d) & d <= nTargets(trialIndex)
            Screen('CopyWindow', winDiskCorrect, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
            Screen('CopyWindow', winDiskCorrect, winDB(2), [], rectStim(d, :, nFrames), 'transparent');
         elseif diskSelected(d)
            Screen('CopyWindow', winDiskError, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
            Screen('CopyWindow', winDiskError, winDB(2), [], rectStim(d, :, nFrames), 'transparent');
         elseif d <= nTargets(trialIndex)
            Screen('CopyWindow', winDisk, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
            Screen('CopyWindow', winDiskIndicator, winDB(2), [], rectStim(d, :, nFrames), 'transparent');
         else
            Screen('CopyWindow', winDisk, winDB(1), [], rectStim(d, :, nFrames), 'transparent');
            Screen('CopyWindow', winDisk, winDB(2), [], rectStim(d, :, nFrames), 'transparent');
         end
      end
      for d = [1 2 1 2 1 2]
         Screen('CopyWindow', winDB(d), winMain, [], rectDisplay);
         WaitSecs(1/3);
      end
   end

   CenterText(winMain, 'Click to continue', colText);
   MouseWait(winMain);

   Screen('CopyWindow', winDisplayBlank, winMain, [], rectDisplay);
end

Screen(winMain, 'FillRect', colBackground);
mesg = {'Block is complete.'; 'Please inform the experimenter.'};
CenterCellText(winMain, mesg, colInstructions, 40);
FlushEvents('keyDown');
GetChar;

Screen('CloseAll');



function MouseWait (win)

FlushEvents('mouseUp', 'mouseDown');
[x, y, button] = GetMouse(win);
if any(button)
   while any(button)
      [x, y, button] = GetMouse(win);
   end
end
while ~any(button)
   [x, y, button] = GetMouse(win);
end



function [newX, newY] = CenterText (window, message, color, xoffset, yoffset)

if nargin < 2
   error([mfilename ' requires at least two arguments']);
end
if nargin < 3 | isempty(color)
   color = [];
end
if nargin < 4 | isempty(xoffset)
   xoffset = 0;
end
if nargin < 5 | isempty(yoffset)
   yoffset = 0;
end

windowRect = screen(window, 'Rect');
width = screen(window, 'TextWidth', message);
[newX, newY] = screen(window, 'DrawText', message, ((windowRect(3)/2)-(width/2))+xoffset, (windowRect(4)/2)+yoffset, color);


function [newX, newY] = CenterCellText(window, messages, color, spacing)

if nargin < 2
   error([mfilename ' requires at least two arguments']);
end
if nargin < 3 | isempty(color)
   color = [];
end
if nargin < 4 | isempty(spacing)
   spacing = 20;
end

lines = length (messages);
middleLine = round(lines/2);
yOffset = spacing*((1:lines)-middleLine);
for y = 1:lines
   [newX, newY] = CenterText(window, messages{y}, color, 0, yOffset(y));
end
