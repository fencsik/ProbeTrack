function track()

%%% track:
%%% presents trials in the Multiple Object Tracking experiments. Uses path files 
%%% generated by generator.m
%%% Authors: David Fencsik (based on file by Todd Horowitz)
%%%
%%% $LastChangedDate$

global screenX
global screenY
global MainWindow
global nDirections

minimumAccuracy = '60%';
% min/max frame duration in ms: if average frame duration is outside of these bounds, then
% panic and exit. The MATLAB interpreter is occassionally off and this catches it.
minFrameDuration = 11;
maxFrameDuration = 20;

screenNumber = max(Screen('Screens'));

logging = 0;
if logging;
   LogFileName = ['track.log'];
   logFile = fopen(LogFileName,'a');
   fprintf(logFile, '\nStarted on %s\n', datestr(now));
end;


prompt = {'Subject''s initials',
          'Path file',
          'Target response',
          'Distractor response',
          'Correct for 10-bit DAC (0 = no, 1 = yes)',
          'Tracers? (0 = no, 1 = yes)'
          };
defaults = {'xxx', 'a1', '''', 'a', '0', '0'};
answer = inputdlg(prompt, 'Experimental Setup Information', 1, defaults);
% check for cancel button-press
if size(answer) < 1
   fprintf('Experiment cancelled\n');
   return
end;

% now decode answer
[subject, pathsFile, responseTarget, responseDistractor, set10BitDAC, tracer] = deal(answer{:});
set10BitDAC = str2num(set10BitDAC);
tracer = str2num(tracer);

% derive initial 3 letters of subject name 
[junk nameSize] = size(subject);
if nameSize < 3
	sInitial = subject;
	sInitial((nameSize+1):3) = 'x';
else
	sInitial = subject(1:3);
end

% allowed responses
responseTarget = KbName(responseTarget(1));
responseDistractor = KbName(responseDistractor(1));
allowedResponses = [responseTarget, responseDistractor];


% video setup
imageX=35;
imageY=35;
imageRect = [0 0 imageX imageY];
coreRect = imageRect - [0 0 4 4];
ballRect = CenterRect(coreRect, imageRect);
MainWindow = screen(screenNumber, 'OpenWindow', [], [], 8);
screenRect = screen(screenNumber, 'Rect');
screenX = screenRect(3);
screenY = screenRect(4);
hz = round(screen(MainWindow, 'FrameRate'));

white = WhiteIndex(MainWindow);
black = BlackIndex(MainWindow);
gray = round((white+black)/2);
if round(gray)==white
	gray=black;
end
darkGray = (gray+black)/2;
lightGray = (gray+white)/2;
% now set colors
red = 1;
blue = 2;
green = 3;
yellow = 4;
offwhite = 5;
clut = screen(MainWindow, 'GetClut');
clut (red + 1, :)      = [255 0 0];
clut (blue + 1, :)     = [0 0 255];
clut (green + 1, :)    = [0 255 0];
clut (yellow + 1, :)   = [255 255 0];
clut (offwhite + 1, :) = [254 254 254];
LoadClut(MainWindow, clut);
if set10BitDAC == 1
   LoadClut(MainWindow, clut*1023/255);
end;


screen(MainWindow, 'FillRect', gray);
screen(MainWindow, 'TextFont', 'Times');
screen(MainWindow, 'TextSize', 24);
hidecursor;
% framesPerMovieFrame = 2;

% load functions into memory
% these functions take time to load into memory, but will remain in memory until cleared

screen('Screens'); % this function opens or cloeses windows on or off screen
centerrect(imageRect, screenRect);% centers first rect in second rect
KbCheck; % checks whether a key is pressed down
GetSecs; % returns the number of seconds since the computer started

% set the state of the random number generator to some random value (based on the clock)
tau = clock;
rand('state',sum(100*tau));
state=rand('state');
seedFileName = ['seed-', sInitial];
save (seedFileName, 'tau');

% open other windows

% off screen stimulus window
stimulus(1) = screen(MainWindow, 'OpenOffscreenWindow', [], screenRect);
stimulus(2) = screen(MainWindow, 'OpenOffscreenWindow', [], screenRect);

screen(stimulus(1), 'FillRect', gray);
screen(stimulus(2), 'FillRect', gray);

% big eraser
screenBlank=screen(MainWindow, 'OpenOffscreenWindow',  gray, screenRect); 

%make some beeps
[beep, samplingRate] = makeBeep(880,.2);
[errbeep, samplingRate] = MakeBeep(220,.3);
Snd('Play', beep);


pointerNames = {'ballPointer', 
                'currentSelectionBall', 
                'selectedCorrectBall', 
                'unselectedCorrectBall', 
                'selectedErrorBall',
                'probeBall'};
diskBackgroundColors = {      '[]', 'offwhite',    '[]',     '[]',  '[]',     '[]'};
diskForegroundColors = {'offwhite', 'offwhite', 'green', 'yellow', 'red', 'yellow'};
for p = 1:length(pointerNames)
   eval([pointerNames{p}, ' = screen(MainWindow, ''OpenOffScreenWindow'', ', diskBackgroundColors{p}, ', imageRect);']);
   eval(['screen(', pointerNames{p}, ', ''FillOval'', black, imageRect);']);
   eval(['screen(', pointerNames{p}, ', ''FillOval'',', diskForegroundColors{p}, ', ballRect);']);
end
eraserPointer = screen(MainWindow, 'OpenOffScreenWindow', [], imageRect);
screen(eraserPointer, 'FillOval', gray, imageRect);

%%% Tracer code: tracers currently work by finding the first disk's
%%% disappearance location, putting up a dot there, and then ending the
%%% trial as soon as that disk reappears.
if tracer;
   %minFrameDuration = minFrameDuration * 2;
   %maxFrameDuration = maxFrameDuration * 2;

   tracerSize = 16;
   tracerRect = [0 0 tracerSize tracerSize];
   tracerPointer = screen(MainWindow, 'OpenOffScreenWindow', [], tracerRect);
   screen(tracerPointer, 'FillOval', red, tracerRect);
end;


load(pathsFile);
%responseMode = 1;
nDisks = size(paths{1}, 1);
nTrials = size(paths, 2);
nTrialString = num2str(nTrials);

dataFileName = [experiment 'Data.txt'];
dataFile = fopen(dataFileName, 'a');
fprintf(dataFile,['experiment,sub,time,pathfile,prac,trial,nframes,blankframes,framedur,' ... 
                  'speed,ndisks,ntargets,normShift,oddShift,oddDisk,probeDisk,error,nerrors,rt\n']);
fclose(dataFile);


% instructions
nDiskString = num2str(nDisks);
tracknumberString = num2str(nTargets);
if nTargets == 1
   verbEnd = 's';
   nounEnd = '';
else
   verbEnd = '';
   nounEnd = 's';
end;

instructionsTask1 = {
      'In this experiment, you are asked to';
      'keep track of some disks on the screen.';
      'At the beginning of each trial, you will';
      'see several disks on a gray background.';
      'Some of these disks will blink on and off:';
      'These are your targets.';
                   };

instructionsTask2 = {
      'After the targets stop blinking, all the disks';
      'will start to move around the screen.';
      'At some point during the trial, all of the';
      'disks will disappear briefly, and then reappear';
      'and stop moving.';
      '';
      'Your task is to keep track of the targets';
      'throughout the trial.';
      };

% remove mention of blank interval if there is none
if blankDuration > 0
   lines2Start = 3;
   lines2Remove = 3;
   for a = lines2Start:(length(instructionsTask2) - lines2Remove)
      instructionsTask2{a} = instructionsTask2{a + lines2Remove};
   end
   for a = (length(instructionsTask2) - lines2Remove + 1):length(instructionsTask2)
      instructionsTask2{a} = '';
   end
end

if responseMode == 1
   instructionsResponse = {
         'When the trial ends, the arrow cursor will appear.';
         'Use the mouse to click on all of the targets.';
         'If you click on a target, it will be highlighted in green';
         'and you will hear a high tone.';
         'If you click on a non-target, it will be highlighted in red';
         'and you will hear a low tone.';
         'You get one chance for every target that flashed at the beginning of the trial.';
         'Once you are done, any targets you missed will blink in yellow.';
                   };
elseif responseMode == 3
   instructionsResponse = {
         'When the trial ends, one of the disks will be highlighted in yellow.';
         'You must decide if this disk was a target or not.';
         'Press the RED button if you think it was a TARGET.';
         'Press the BLUE button if you think it was a DISTRACTOR.';
         'If you are correct, the disk will be highlighted in green';
         'and you will hear a high tone.';
         'If you are incorrect, it will be highlighted in red';
         'and you will hear a low tone.';
                   };
end
   
instructionsFeedback = {
      'After each experimental trial, you will receive feedback'
      'on your performance so far.';
      'The feedback will tell you how you did on the previous trial';
      'and how you have done on all trials for the current block.';
      ['Your goal should be to maintain an overall accuracy of at least ' minimumAccuracy '.'];
                   };

screen('CopyWindow', screenBlank, MainWindow);
% task instructions 1
CenterCellText(MainWindow, instructionsTask1, 50);
CenterText('press any key to continue', 0, 300);
FlushEvents('keyDown');
GetChar;
screen('CopyWindow', screenBlank, MainWindow);
% task instructions 2
CenterCellText(MainWindow, instructionsTask2, 50);
CenterText('press any key to continue', 0, 300);
FlushEvents('keyDown');
GetChar;
screen('CopyWindow', screenBlank, MainWindow);
% response instructions
CenterCellText(MainWindow, instructionsResponse, 50);
CenterText('press any key to continue', 0, 300);
FlushEvents('keyDown');
GetChar;
screen('CopyWindow', screenBlank, MainWindow);

slowFlag = 0;

[newX newY] = CenterText(['Press any key to begin ', num2str(nTrials), ' trials']);
FlushEvents('keyDown');
GetChar;
Screen('CopyWindow', screenBlank, MainWindow);

nTracked = zeros(nTrials,1);
correct = 0;

% define the stimulus presentation loop
% time is measured in frames, and measures the total stimulus time
% the frame array keeps track of which frame of its trajectory each
% object is in.
loop = {
'   pointer = ballPointer;'
'   for frame = 1:trialFrames;'
'      thisFrame = mod(frame - 1, 2) + 1;'
'      lastFrame = mod(frame, 2) + 1;'
'      time1 = GetSecs;'
'      for n = 1:nDisks'
'         if frame > 1;'
'            screen(''CopyWindow'', eraserPointer, stimulus(lastFrame), imageRect, stimRect(n, :, frame-1), ''transparent'');'
'         end;'
'         screen(''CopyWindow'', pointer, stimulus(thisFrame), imageRect, stimRect(n, :, frame), ''transparent'');'
'      end;'
'      screen(MainWindow, ''WaitBlanking'', 1);'
'      screen(''CopyWindow'', stimulus(thisFrame), MainWindow);'
'      frameDuration(frame) = GetSecs - time1;'
'   end;'
};

for trial = 1:nTrials
   trialString = num2str(trial);
   timestamp = datestr(now);

   if trial <= pracTrials
      practice = 1;
   else
      practice = 0;
   end

   trajectory = paths{trial};
   trialFrames = size(trajectory, 3);
   if exist('probeDisk')
      probes = probeDisk(trial, :);
   end

   %%% convert from points to rects
   stimRect = zeros(nDisks, 4, trialFrames);
   for f = 1:trialFrames
      for d = 1:nDisks
         stimRect(d, :, f) = CenterRectOnPoint(imageRect, trajectory(d, 1, f), trajectory(d, 2, f));
      end
   end
   
%    % if we're using tracers, then find the appropriate frames and locations
%    if tracer
%       gapFrames = find(trajectory(1, 1, :) < 0);
%       tracerFrame = gapFrames(1);
%       trialFrames = gapFrames(length(gapFrames)) + 1;
%       tracerRect = CenterRectOnPoint(tracerRect, ...
%                                      trajectory(1, 1, tracerFrame-1), ...
%                                      trajectory(1, 2, tracerFrame-1));
%    end;
   
   hidecursor;
   screen('CopyWindow', screenBlank, stimulus(1)); 
   screen('CopyWindow', screenBlank, stimulus(2)); 
   screen('CopyWindow', screenBlank, MainWindow);

   %%%       % generate tracers
   %%%       if tracer;
   %%%          %screen('CopyWindow', screenBlank, tracerPaths,[],[],'transparent');
   %%%          for d = 1:nDisks;
   %%%             screen(tracerPaths, 'DrawLine', blue, ...
   %%%                    trajectory(d, 1, lastVisibleFrame)-imageX/2, (trajectory(d, 2, lastVisibleFrame))-imageY/2, ...
   %%%                    trajectory(d, 1, trialFrames)-imageX/2,      (trajectory(d, 2, trialFrames))-imageY/2);
   %%%             screen('CopyWindow', firstTracerPointer, tracerPaths, imageRect, ...
   %%%                    [trajectory(d, 1, trialFrames)-imageX (trajectory(d, 2, trialFrames))-imageY ...
   %%%                    trajectory(d, 1, trialFrames),      (trajectory(d, 2, trialFrames))], ...
   %%%                    'transparent');
   %%%          end;
   %%%       end;

   [newX newY] = CenterText(['Press any key to begin trial ', trialString, ' of ' nTrialString]);
   FlushEvents('keyDown');
   GetChar;
   screen('CopyWindow', screenBlank, MainWindow);
   for d = 1:nDisks
      screen('CopyWindow', ballPointer, stimulus(2), imageRect, stimRect(d, :, 1), 'transparent');
      if d > nTargets
         screen('CopyWindow', ballPointer, stimulus(1), imageRect, stimRect(d, :, 1), 'transparent');
      end
   end
   
   timestamp = datestr(now);
   
   %flash the tracked balls 4 times to cue them
   for flash = 1:9
      screen('CopyWindow', stimulus(mod(flash,2)+1), MainWindow);
      WaitSecs(.5);
   end
   
   %clear the stimulus window
   % 		screen('CopyWindow', screenBlank, MainWindow);
   screen('CopyWindow', screenBlank, stimulus(1));
   screen('CopyWindow', screenBlank, stimulus(2));
   FlushEvents('keydown');
   
   % now present stimuli
   
   initTime = getsecs; %check the start time time
   time1 = initTime;
   frameDuration = zeros(trialFrames,1);
   frameOffset = zeros(1,nDisks);
   frame = 1;
   
   if logging;
      fprintf(logFile, '  Entering loop...');
   end;
   
   % show the movie:	
   priorityLevel=MaxPriority(MainWindow,'WaitBlanking');
   rush(loop,priorityLevel);
   
   if logging;
      fprintf(logFile, 'done\n');
   end;
   
   if logging;
      fprintf(logFile, '  Starting response collection...');
   end;
   

   %%% handle different response modes:
   %%% 1 = full report
   %%% 2 = cue two/pick target
   %%% 3 = cue one, speeded target/distractor discrimination
   testFrame = trialFrames;
   if responseMode == 3
      keyPress = 0;
      keyTime = 0;
      keyCode = -1;
      FlushEvents('keydown');

      %%% working here: need to revise below to only cue one disk
      probe = probes(1);
      FlushEvents('keydown');
      Screen('CopyWindow', probeBall, MainWindow, imageRect, stimRect(probe, :, testFrame), 'transparent');

      Screen(MainWindow, 'WaitBlanking');
      probeOnsetTime = GetSecs;
      while 1
         [keyPress, keyTime, keyCode] = KbCheck;
         if keyPress & any(keyCode(allowedResponses))
            responseTime = keyTime;
            break;
         end
      end

      response = find(keyCode);
      if length(response) > 1
         error = -2;
      elseif probe <= nTargets
         if response == responseTarget
            error = 0;
         else
            error = 1;
         end
      else
         if response == responseDistractor
            error = 0;
         else
            error = 1;
         end
      end
      if error == 0
         snd('play', beep);
         Screen('CopyWindow', selectedCorrectBall, MainWindow, imageRect, stimRect(probe, :, testFrame), 'transparent');
      else
         snd('play', errbeep);
         Screen('CopyWindow', selectedErrorBall, MainWindow, imageRect, stimRect(probe, :, testFrame), 'transparent');
      end
      nErrors = error;
      latency = responseTime - probeOnsetTime;
      
   elseif responseMode == 1
      FlushEvents('mouseUp', 'mouseDown');
      ShowCursor;

      locationError = ones(1, nTargets);%everything starts as an error
      
      % compute center of each stimulus
      nClicks = 0;
      diskVector = zeros(1, nDisks);
      
      while nClicks < nTargets
         button = 0;
         while button == 0
            % redraw stimulus
            [x, y, button] = getmouse;
            for d = 1:nDisks
               if diskVector(d) == 1
                  screen('CopyWindow', selectedCorrectBall, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
               elseif diskVector(d) == 2
                  screen('CopyWindow', selectedErrorBall, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
               else
                  if IsInRect(x, y, stimRect(d, :, testFrame))
                     screen('CopyWindow', currentSelectionBall, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
                  else
                     screen('CopyWindow', ballPointer, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
                  end
               end
            end
            [x, y, button] = getmouse;
            if button == 1 %if the mouse button is pressed
               while button == 1 %wait until it is released
                  [x, y, button] = getmouse; %get the x,y coordinates of the location at which the mouse button was released
               end
               button = 1; %reset the button to 1 so that you can break out of the loop
            end
         end
         
         % is mouse within this rect?
         clickedInARect = 0;
         for d = 1:nDisks
            if IsInRect(x, y, stimRect(d, :, testFrame))
               if diskVector(d) == 0
                  clickedInARect = 1;
                  if d <= nTargets
                     screen('CopyWindow', selectedCorrectBall, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
                     snd('play', beep);
                     locationError(d) = 0;
                     diskVector(d) = 1;
                  else
                     screen('CopyWindow', selectedErrorBall, MainWindow, imageRect, stimRect(d, :, testFrame), 'transparent');
                     snd('play', errbeep);
                     diskVector(d) = 2;
                  end
               end %if diskVector(d) == 0
            end %if IsInRect(x, y, stimRect(d, :, testFrame))
         end %for d = 1:nDisks
         if clickedInARect == 1
            nClicks = nClicks + 1;
         end
         
      end % while nClicks...
      
      screen('CopyWindow', screenBlank, stimulus(1));
      screen('CopyWindow', screenBlank, stimulus(2));
      
      % if there were any errors, then flash the unselected correct disks:
      if any(diskVector == 2)
         for d = 1:nDisks
            if d <= nTargets
               if diskVector(d) == 0
                  screen('CopyWindow', ballPointer, stimulus(2), [], stimRect(d, :, testFrame), 'transparent');
                  screen('CopyWindow', unselectedCorrectBall, stimulus(1), [], stimRect(d, :, testFrame), 'transparent');
               else
                  screen('CopyWindow', selectedCorrectBall, stimulus(2), [], stimRect(d, :, testFrame), 'transparent');
                  screen('CopyWindow', selectedCorrectBall, stimulus(1), [], stimRect(d, :, testFrame), 'transparent');
               end
            elseif d > nTargets
               if diskVector(d) == 0
                  screen('CopyWindow', ballPointer, stimulus(2), [], stimRect(d, :, testFrame), 'transparent');
                  screen('CopyWindow', ballPointer, stimulus(1), [], stimRect(d, :, testFrame), 'transparent');
               else	
                  screen('CopyWindow', selectedErrorBall, stimulus(2), [], stimRect(d, :, testFrame), 'transparent');
                  screen('CopyWindow', selectedErrorBall, stimulus(1), [], stimRect(d, :, testFrame), 'transparent');
               end
            end
         end
         %flash the unselected correct balls 3 times
         for flash = 1:6
            screen('CopyWindow', stimulus(mod(flash,2)+1), MainWindow);
            WaitSecs(.333);
         end
      end
      
      hidecursor;
      
      error = max(locationError);
      nErrors = sum(locationError);
      latency = 0;
   else
      error(sprintf('%s: response mode %d not implemented', mfilename, responseMode));
   end

   if logging;
      fprintf(logFile, 'done\n');
   end;
      
   %trialDuration = GetSecs - initTime
   averageFrameDuration = sum(frameDuration) / trialFrames * 1000;
   % 		max(frameDuration)*1000
   % 		min(frameDuration)*1000
   
   % save data
   dataFile = fopen(dataFileName, 'a');
   %fprintf(dataFile,['experiment,sub,time,pathfile,prac,trial,nframes,blankframes,framedur,' ... 
   %                  'speed,ndisks,ntargets,normShift,oddShift,oddDisk,probeDisk,error,nerrors,rt\n');
   count = fprintf(dataFile, ...
                   '%s,%s,%s,%s,%d,%d,%d,%d,%6.4f,%d,%d,%d,%d,%d,%d,%d,%d,%d,%6.6f\n', ...
                   experiment, subject, timestamp, pathsFile, practice, ...
                   trial, trialFrames, blankDuration, averageFrameDuration, ...
                   movementRate, nDisks, nTargets, normShift, oddShift, oddDisk(trial), probeDisk(trial), ...
                   error, nErrors, latency);
   fclose(dataFile);
   
   % if framerate is too slow or too fast, then exit with a warning:
   if averageFrameDuration < minFrameDuration | averageFrameDuration > maxFrameDuration
      feedbackString = {'COMPUTER ERROR:  BAD FRAME DURATION';
                        ['Average frame duration = ' num2str(averageFrameDuration)];
                        '';
                        'The block needs to be restarted.';
                        'Please inform the experimenter immediately.';
                        '';
                        'Experimenter: Press any button to exit,';
                        'then restart the block.'
                       };
      screen('CopyWindow', screenBlank, MainWindow);
      CenterCellText(MainWindow, feedbackString, 30);
      FlushEvents('keyDown');
      GetChar;
      break;
   end;

   
   [newX newY] = CenterText('Press any key to continue', 0, 0, black);
   FlushEvents('keyDown');
   GetChar;
   screen('CopyWindow', screenBlank, MainWindow);

%    nTracked(trial) = nTargets - nErrors;
%    correct = correct + (1 - error);
   
%    feedbackString = {['Last Trial: ' num2str(nTracked(trial)) '/' num2str(nTargets) ' correct'];
%                      ['Average of: ' num2str(sum(nTracked(1:trial))/trial,2) '/' num2str(nTargets) ' correct'];
%                      ' ';
%                      ' ';
%                      'Press any key to continue'
%                     };

%    [newX newY] = CenterCellText(MainWindow, feedbackString, 30);
%    FlushEvents('keyDown');
%    GetChar;
end % trial loop

if slowFlag > 0
   break;
end;

if logging;
   fprintf(logFile, 'Finished on %s\n', datestr(now));
   fclose(logFile);
end;

clear screen;
