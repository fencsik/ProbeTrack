function pathsFile = tGenerator8a (sInitial)% stGenerator:% generates a set of trajectories for use with ShiftTrack experiments% Authors: David Fencsik (based on file by Todd Horowitz)%% $Id: generator.m,v 1.1 2003/11/10 17:08:57 fencsik Exp $% Modified by David Fencsik% started  9/29/2003% based on tGenerator6c of  9/15/2003% version of  10/14/2003% note: sometimes items get stuck near the border and have a wobbly motion when they're supposed to be ballistic% not sure how to fix this problemtrialTypes = [0.0];nTrialTypes = size(trialTypes,2);%MainWindow = screen(0, 'OpenWindow', [], [], 8);imageX=50;imageY=50;imageRect = [0 0 imageX imageY];screenX = 1024;screenY = 768;screenRect = [0 0 screenX screenY];%hz = round(screen(MainWindow, 'FrameRate'));clear screen;% get experimental infoprompt = {'number of subjects', 'trial duration (sec)', 'number of disks', ['repetitions (x' num2str(nTrialTypes) ' conditions)'], 'path file prefix'};defaults = {'1', '5', '10', '10', 'p_4-'};answer = inputdlg(prompt, 'Basic Setup Information', 1, defaults);% now decode answer[nSubjects, trialDuration, nDisks, repetitions, prefix] = deal(answer{:});nSubjects = str2num(nSubjects);trialDuration = str2num(trialDuration);nDisks = str2num(nDisks);repetitions = str2num(repetitions);trialTypesMasterList = repmat(trialTypes, 1, repetitions);nTrials = size(trialTypesMasterList,2);% get motion parametersprompt = {'speed (deg/sec)', 'noise (deg/sec)', 'buffer zone (pixels)', 'estimated time per frame (ms)', 'blank interval (frames)'};defaults = {'6', '0', '70', '13.33', '23'};answer = inputdlg(prompt, ['Motion Parameters: "' prefix '"'], 1, defaults);% now decode answer[movementRate, movementNoise, bufferZone, predictedMovieFrameDuration, blankDuration] = deal(answer{:});movementRate = str2num(movementRate);movementNoise = str2num(movementNoise);bufferZone = str2num(bufferZone);predictedMovieFrameDuration = str2num(predictedMovieFrameDuration);blankDuration = str2num(blankDuration);%  major variables%frameDuration = refreshesPerFrame/hz;edgeZone = imageY;estMovieFrames = ceil(trialDuration*1000/predictedMovieFrameDuration);fullCircle = 24;halfCircle = 12;% increment = (rate*30)*(frameDuration);targetMagnitude = (movementRate*30)*(predictedMovieFrameDuration)/1000;targetNoiseMagnitude = (movementNoise*30)*(predictedMovieFrameDuration)/1000;%distractorMagnitude = (distractorRate*30)*(predictedMovieFrameDuration);%distractorNoiseMagnitude = (distractorNoise*30)*(predictedMovieFrameDuration);degreesPerDirection = 360/24;tau = clock;rand('state',sum(100*tau));state=rand('state');% startCoordinates = zeros(nBalls, 2);xdim = 5; ydim = 6;% a 5 by 6 grid of positionswindowX = 100;windowY = 100;% each cell is 125 by 125 pixelscxy = newGrids(xdim, ydim, windowX, windowY, screenRect);for subject = 1:nSubjects%	initTime = GetSecs;	kills = 0;		shiftFactor = Shuffle(trialTypesMasterList);	shiftAmount = ceil((shiftFactor-1.0) * blankDuration);	movieFrames = ones(1, nTrials) * estMovieFrames + shiftAmount;		for trial = 1:nTrials				% compute trajectories		deathFlag = 999;		while deathFlag > 0% 			if kills > 1000;% 				clear screen;% 				kills% 				return;% 			end;									% create a random permutation of the 35 possible locations			randselect = randperm(xdim*ydim);						%starting positions for each ball are selected from the randomset			startCoordinates = cxy(randselect(1:nDisks), :);			oldCoordinates = startCoordinates;			newCoordinates = startCoordinates;			direction = Randi(24, [nDisks 1]); % initial random directions in 24 degree increments			theta = (direction*30)*(pi/180); % initial direction in radians			% set up vectors of individual signal and noise magnitudes			magnitude = ones(nDisks, 1) * targetMagnitude; 			noiseMagnitude = ones(nDisks, 1) * targetNoiseMagnitude; 			%magnitude(1:tracknumber) = targetMagnitude;			%noiseMagnitude(1:tracknumber) = targetNoiseMagnitude;						trajectory = zeros(nDisks, 2, movieFrames(trial));						deathFlag = 0;			for f = 1:movieFrames(trial)				% while loop waits until a viable trajectory is generated				count = 0;				count = count+1;				noiseDirection = Randi(24, [nDisks 1]); % random directions in 24 degree increments								[finalTheta, finalMagnitude] = addNoiseVector(direction, magnitude, noiseDirection, noiseMagnitude); % adds a noise vector with random direction and noiseFactor*magnitude magnitude to the signal vector				newCoordinates = computeCoordinates(oldCoordinates, finalTheta, finalMagnitude); % recompute coordinates								% now prevent distractors from going out of bounds								for a = 1:nDisks					if (newCoordinates(a, 2) > (screenY - edgeZone))						% approaching floor						direction(a) = halfCircle - direction(a);					elseif (newCoordinates(a, 2) < edgeZone)						% approaching ceiling						direction(a) = halfCircle - direction(a);					elseif (newCoordinates(a, 1) > (screenX - edgeZone))						% 						if (newCoordinates(a, 1) > (screenX - edgeZone))						% approaching right edge						direction(a) = fullCircle - direction(a);					elseif (newCoordinates(a, 1) < edgeZone)						% approaching left edge						direction(a) = fullCircle - direction(a);					else						% do nothing											end				end							[finalTheta, finalMagnitude] = addNoiseVector(direction, magnitude, noiseDirection, noiseMagnitude); % adds a noise vector with random direction and noiseFactor*magnitude magnitude to the signal vector				newCoordinates = computeCoordinates(oldCoordinates, finalTheta, finalMagnitude); % recompute coordinates								% now double-check to see if there is occlusion or boundary violation								for a = 1:nDisks					if (newCoordinates(a, 2) > (screenY - imageY))|(newCoordinates(a, 2) < imageY)						% floor or ceiling						deathFlag = 1;						kills = kills +1;% 						['vertical boundary violation with ball ' num2str(a)]% 						['  coordinates (' num2str(newCoordinates(a, 1)) ',' num2str(newCoordinates(a, 2)) ')']% 						['  frame ' num2str(f)']% 						clear screen;% 						return;					elseif (newCoordinates(a, 1) > (screenX - imageX))|(newCoordinates(a, 1) < imageX)						deathFlag = 2;						kills = kills +1;% 						['horizontal boundary violation with ball ' num2str(a)]% 						['  coordinates (' num2str(newCoordinates(a, 1)) ',' num2str(newCoordinates(a, 2)) ')']% 						clear screen;% 						return;					end				end							% now prevent balls from occluding one another on final frame				if f == movieFrames(trial)					for b = 1:nDisks						for c = (b+1):nDisks							cbd = newCoordinates(b, :) - newCoordinates(c, :);							interElementDistance = sqrt(sum(cbd.^2));							if interElementDistance < bufferZone								deathFlag = 3;								kills = kills +1;% 								['occlusion between balls ' num2str(b) ' and ' num2str(c) ' on final frame ']% 								clear screen;% 								return;							end						end					end				end							trajectory(:, :, f) = newCoordinates;				%set the old coordinates (for the next frame) equal to the coordinates used for the current frame 				oldCoordinates = newCoordinates;			end		end			paths{trial} = trajectory;		starts{trial} = startCoordinates;		clear trajectory;	end%	endTime = GetSecs;	%timePassed = endTime - initTime	kills	subjectString = num2str(subject);	outputFileName = [prefix, subjectString];	save (outputFileName,  'paths', 'starts', 'movementRate', 'movementNoise', 'trialDuration', 'blankDuration', 'nTrials', 'nDisks', 'predictedMovieFrameDuration', 'movieFrames', 'shiftFactor', 'shiftAmount');    fprintf(1, 'Finished %s.\n', outputFileName);endfunction newCoordinates = computeCoordinates(oldCoordinates, theta, magnitude)% global increment%calculate the next positionnewCoordinates(:, 1) = magnitude.*sin(theta) + oldCoordinates(:, 1); %x coordinate of the next pointnewCoordinates(:, 2) = magnitude.*cos(theta) + oldCoordinates(:, 2); %y coordinate of the next pointfunction [finalTheta, finalMagnitude] = addNoiseVector(direction, magnitude, noiseDirection, noiseMagnitude)degreesPerDirection = 360/24;direction = mod(direction - 1, 24) + 1; % eliminate negative directionstheta = (direction*degreesPerDirection)*(pi/180); % direction to radiansnoiseTheta = (noiseDirection*degreesPerDirection)*(pi/180); % noise direction in radians%now convert to cartesian coordinates and add[signalX, signalY] = pol2cart(theta, magnitude);[noiseX, noiseY] = pol2cart(noiseTheta, noiseMagnitude);finalX = signalX + noiseX;finalY = signalY + noiseY;[finalTheta, finalMagnitude] = cart2pol(finalX, finalY);